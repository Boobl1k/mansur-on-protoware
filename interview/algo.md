# Algo

## Объясните разницу между массивом и связанным списком.

===

Массив хранит элементы в непрерывной области памяти, обеспечивая быстрый доступ по индексу O(c), но вставка и удаление могут быть затратными O(n). Требует цельный кусок памяти.

Связанный список хранит элементы в виде узлов со ссылками на следующий элемент, обеспечивая более эффективную вставку и удаление O(c), но доступ к элементам по индексу медленнее O(n). Может располагаться в разных участках памяти.

===

## Как работает двоичный поиск и в каких условиях его можно применять?

===

Двоичный поиск - алгоритм поиска элемента в отсортированном массиве, который делит диапазон поиска пополам на каждом шаге, обеспечивая эффективное время выполнения O(log n).  
Возможен при отсортированных массивах данных.

===

## Что такое стек и очередь, и какие операции они поддерживают?

===

Структуры данных. Стек - "последний вошел, первый вышел", очередь - "первый вошел, первый вышел"

Операции:
* enqueue/push: Добавляет элемент в конец очереди / на вершину стека.
* dequeue/pop: Удаляет и возвращает элемент из начала очереди / с вершины стека.
* peek: Возвращает элемент из начала очереди / с вершины стека без его удаления.

===

## Какие виды сортировок вы знаете и можете описать?

===

1. Сортировка пузырьком (Bubble Sort):
   * Повторяет проход по списку множество раз, сравнивая каждую пару соседних элементов и меняя их местами, если они находятся в неправильном порядке.
   * На каждом проходе самый большой (или меньший, в зависимости от порядка сортировки) элемент "всплывает" на своё место.
   * Один из наиболее простых и медленных алгоритмов сортировки.
   * n - n2 - n2, memory c

2. Сортировка вставками (Insertion Sort):
   * Проходит по списку и постепенно строит отсортированную последовательность.
   * На каждом шаге берется следующий элемент из неотсортированной части и вставляется в подходящее место в уже отсортированной части.
   * Эффективен для небольших списков или почти упорядоченных списков.
   * n - n2 - n2, memory c

3. Сортировка выбором (Selection Sort):
   * На каждом шаге находится минимальный (или максимальный) элемент из неотсортированной части списка и меняется местами с первым элементом неотсортированной части.
   * По сравнению с сортировкой пузырьком, имеет меньше обменов элементов.
   * Однако он всё равно имеет квадратичную сложность времени выполнения.
   * n2 - n2 - n2, memory c

4. Сортировка слиянием (Merge Sort):
   * Рекурсивно разбивает список на две части, сортирует каждую из них, а затем объединяет отсортированные части вместе.
   * Одна из самых эффективных алгоритмов сортировки.
   * Обеспечивает стабильность сортировки (поддерживает порядок элементов с равными значениями).
   * n log n - n log n - n log n, memory n

5. Быстрая сортировка (Quick Sort):
   * Выбирает элемент, называемый опорным, и разбивает массив на две части: элементы, меньшие опорного, и элементы, большие опорного. Затем рекурсивно применяет алгоритм к каждой из частей.
   * Один из наиболее эффективных алгоритмов сортировки, особенно на практике. Однако он может быть нестабильным. Худшее время n2 например когда алгоритм каждый раз выбирает минимальный элемент как опорный.
   * n log n - n log n - n2, memory n

===

## Что такое хеш-таблица и как она реализована в Java?

===

Структура данных, которая использует хеш-функцию для преобразования ключей в индексы массива, где хранятся значения. 
Она обеспечивает быстрый доступ к данным путем напрямую обращаясь к соответствующей ячейке массива. 

Ключевые шаги в работе хеш-таблицы:
* Хеширование ключей: Каждый ключ преобразуется в уникальный хеш-код с помощью хеш-функции.
* Индексация: Хеш-код используется для определения индекса массива, где будет храниться значение.
* Разрешение коллизий: Коллизии, когда разные ключи имеют одинаковый хеш-код, разрешаются специальными методами, такими как метод цепочек или открытая адресация.
* Доступ к данным: Для поиска элемента хеш-код вычисляется снова, чтобы найти соответствующий индекс массива, где он хранится.

Хеш-таблицы обеспечивают высокую производительность операций вставки, удаления и поиска, если правильно подобрана хеш-функция и учтены возможные коллизии.

===

## Объясните, что такое дерево бинарного поиска и каковы его основные операции.

===

Дерево бинарного поиска (BST) - это структура данных, где каждый узел имеет не более двух потомков: левый и правый. 
Узлы располагаются так, чтобы все узлы в левом поддереве меньше текущего узла, а все узлы в правом поддереве больше текущего узла.

Основные операции:
* Вставка: Добавление нового элемента в дерево так, чтобы сохранялось условие бинарного поиска.
* Удаление: Удаление элемента из дерева с сохранением его структуры. Могут быть случаи, когда у удаляемого узла есть один или два потомка.
* Поиск: Поиск элемента в дереве. Операция проходит по дереву, начиная с корня, сравнивая значения узлов.
* Обход: Процесс посещения всех узлов в дереве. Включает в себя такие методы как прямой, префиксный и постфиксный обходы.

Деревья бинарного поиска обеспечивают эффективный поиск, вставку и удаление элементов, особенно когда дерево сбалансировано.

===

## Что такое граф, и какие типы обхода графов вы знаете?

===

Граф - это абстрактная структура данных, представляющая собой набор вершин (узлов), связанных рёбрами (стрелками). Графы могут быть направленными (рёбра имеют направление) или ненаправленными (рёбра без направления). Они широко используются для моделирования различных отношений или сетей, таких как социальные сети, дорожные сети, сети компьютеров и т. д.

Основные типы обхода графов: DFS, BFS

===

## Как работает алгоритм поиска в глубину (DFS) и поиска в ширину (BFS)?

===

Обход в глубину (Depth-First Search, DFS): При обходе в глубину происходит переход от стартовой вершины к одной из её соседей, а затем рекурсивно "углубление" в граф, пока не будет достигнут конец пути. После этого алгоритм возвращается к предыдущей вершине и исследует другие пути. Обход в глубину часто реализуется с использованием стека или рекурсии.

Обход в ширину (Breadth-First Search, BFS): В отличие от обхода в глубину, при обходе в ширину сначала исследуются все соседние вершины текущей вершины, затем их соседи и так далее. Для этого обычно используется очередь.

===

## Что такое балансировка деревьев и для чего она нужна?

===

Балансировка деревьев - это процесс поддержания равновесия в структуре дерева, чтобы предотвратить его деградацию в неэффективную или даже линейную структуру данных. Целью балансировки является обеспечение оптимальной производительности операций, таких как вставка, удаление и поиск, которые могут стать медленными в несбалансированных деревьях.

Деревья, такие как деревья бинарного поиска, AVL-деревья, красно-черные деревья, Splay-деревья и др., могут быть сбалансированными, если они соответствуют определенным критериям балансировки.

Основные причины для балансировки деревьев включают:
* Предотвращение деградации производительности: В несбалансированных деревьях операции могут выполняться за линейное время, что приводит к неэффективной работе структуры данных. Балансировка позволяет сохранить оптимальную производительность операций даже в худших случаях.
* Обеспечение равномерного распределения данных: Балансировка деревьев способствует равномерному распределению данных по всем уровням дерева, что приводит к минимизации высоты дерева и, следовательно, оптимальной производительности операций.
* Поддержка динамических изменений: Во многих приложениях данные могут изменяться с течением времени. Балансировка позволяет дереву адаптироваться к этим изменениям, сохраняя при этом высокую производительность.

===

## В чем заключается алгоритм Дейкстры и какова его цель?

===

Алгоритм Дейкстры - это алгоритм для нахождения кратчайшего пути от начальной вершины до всех остальных вершин во взвешенном графе с неотрицательными весами рёбер. Основная цель алгоритма Дейкстры - найти кратчайшие пути от одной вершины графа (обычно называемой исходной вершиной или источником) ко всем другим вершинам.

Вот основные шаги алгоритма Дейкстры:
* Инициализация: Устанавливаем начальную вершину и присваиваем ей расстояние 0. Для всех остальных вершин устанавливаем расстояние до них как бесконечность.
* Выбор вершины: На каждом шаге алгоритма выбираем вершину с наименьшим расстоянием из тех, которые ещё не посещены.
* Обновление расстояний: Для каждой соседней вершины выбранной вершины пересчитываем расстояние до неё. Если новое расстояние меньше, чем уже известное, обновляем его.
* Повторение: Повторяем шаги 2 и 3 для всех вершин графа.
* Остановка: Процесс останавливается, когда все вершины графа были посещены.

После выполнения алгоритма Дейкстры можно получить кратчайшие пути от начальной вершины ко всем остальным вершинам. Этот алгоритм полезен, например, при поиске кратчайшего пути в сетях связи, транспортных маршрутах, или при оптимизации маршрутов в компьютерных сетях.

===

## Объясните принцип работы и использование кучи (heap).

===

Куча (Heap) (или пирамида) - это структура данных, которая обеспечивает эффективное выполнение операций вставки и удаления элементов с наивысшим приоритетом. Она используется в различных алгоритмах, таких как сортировка кучей (Heap Sort), поиск кратчайшего пути в алгоритме Дейкстры, а также для реализации приоритетных очередей.

Принцип работы кучи основан на том, что элементы упорядочены таким образом, что каждый элемент имеет значение, не превышающее значения его дочерних элементов (в случае мин-кучи), или не меньше значений своих дочерних элементов (в случае макс-кучи). Это свойство называется свойством кучи.

Вот основные операции с кучей:
* Вставка: Новый элемент добавляется в кучу путем размещения его в конце структуры данных, а затем "просеивания вверх" (sift-up) элемента вверх по дереву, чтобы восстановить свойство кучи.
* Извлечение наивысшего приоритета (peek): Наивысший приоритетный элемент извлекается из кучи, который обычно находится в корне.
* Удаление наивысшего приоритета (pop): Наивысший приоритетный элемент извлекается из кучи, как при операции peek, но также удаляется из структуры данных. После выполнения извлечения последний элемент перемещается на место корня, а затем выполняется "просеивание вниз" (sift-down) этого элемента, чтобы восстановить свойство кучи.

Куча может быть реализована как массив, где каждый элемент хранится на определенной позиции, и его дочерние элементы вычисляются по формулам (например, левый ребенок индекса i имеет индекс 2*i+1, правый ребенок - 2*i+2). Также куча может быть реализована с использованием динамической структуры данных, такой как дерево.

Кучи широко используются для эффективного выполнения операций с приоритетом, таких как выборка максимума или минимума, и они находят применение в различных областях, таких как алгоритмы сортировки, поиск кратчайших путей и многие другие.

===

## Как можно определить цикл в связанном списке?

===

Определение цикла в связанном списке можно осуществить с помощью алгоритма Флойда. Этот алгоритм позволяет обнаружить наличие цикла в связанном списке, если таковой имеется.

Вот как работает этот алгоритм:
1. Используется два указателя, один быстрый (чаще всего называемый "зайцем") и один медленный (чаще всего называемый "черепахой"). Оба указателя начинают движение с начала списка.
2. На каждом шаге быстрый указатель двигается на два узла вперед, а медленный - на один узел вперед.
3. Если связанный список не содержит цикла, быстрый указатель достигнет конца списка (NULL) раньше, чем медленный указатель.
4. Если же в списке есть цикл, то быстрый указатель в конечном итоге обгонит медленный и снова встретится с ним внутри цикла.
5. Если встреча произошла, то можно сделать вывод, что связанный список содержит цикл.

TODO смысл существования алгоритма неочеввиден. Нужно понять чем он лучше наивного способа и в чем разница с другими алгоритмами

===

## Какие алгоритмы вы знаете для решения задачи о рюкзаке?

===

Задача о рюкзаке (Knapsack problem) является одной из классических задач комбинаторной оптимизации, и существует несколько алгоритмов для ее решения. Вот некоторые из них:

1. Жадные алгоритмы:
   * Жадный алгоритм с использованием относительных стоимостей: В этом методе предметы сортируются по их стоимости за единицу веса, а затем выбираются предметы в порядке убывания этого отношения до тех пор, пока вместимость рюкзака не будет превышена. Этот метод не всегда гарантирует оптимальное решение, но иногда может давать приемлемый результат за короткое время.
2. Метод ветвей и границ (Branch and Bound):
   *  метод ветвей и границ: Этот метод разбивает задачу на подзадачи путем рассмотрения всех возможных комбинаций включения или исключения каждого предмета. Затем проводится оценка верхней границы для каждой подзадачи, и некоторые подзадачи могут быть отсечены, если они не могут привести к оптимальному решению.
3. Динамическое программирование:
   * Метод снизу вверх (Bottom-Up): В этом методе значения решений для подзадачи сохраняются в таблице, и затем используются для вычисления решения исходной задачи. Этот метод работает для случаев, когда задача удовлетворяет принципу оптимальной подструктуры и имеет перекрывающиеся подзадачи.
   * Метод сверху вниз (Top-Down): В этом методе используется рекурсивный подход с мемоизацией (запоминанием результатов уже решенных подзадач), чтобы избежать повторных вычислений.
4. Методы на основе линейного программирования:
   * Некоторые вариации задачи о рюкзаке могут быть сформулированы как задачи линейного программирования и решены с использованием методов линейного программирования.

Каждый из этих методов имеет свои преимущества и ограничения, и выбор конкретного метода зависит от характеристик задачи, таких как размер входных данных, ограничения по времени выполнения и требования к точности решения.

===

## Как реализовать поиск подстроки в строке?
## Что такое динамическое программирование и какие задачи им решаются?
## Как работает алгоритм сортировки слиянием и какова его сложность?
## Что такое паттерн проектирования "Строитель" и как он связан со структурами данных?
## Как можно оптимизировать поиск в отсортированном массиве?
## Что такое AVL дерево?
## Как обнаружить и обработать коллизии в хеш-таблице?
