# Java Core

## Что такое OOP и какие его основные принципы?

===


ООП, или объектно-ориентированное программирование, это методология программирования, которая основана на концепции "объектов". Основная идея ООП заключается в том, что программа состоит из объектов, которые взаимодействуют друг с другом, обмениваясь сообщениями. Каждый объект представляет собой экземпляр определенного класса и имеет свои собственные данные (поля) и методы (функции), которые могут работать с этими данными.

Основные принципы ООП включают в себя:
* Инкапсуляция: Это концепция, которая позволяет объединить данные и методы, которые работают с этими данными, внутри одного объекта, скрывая детали реализации от внешнего мира. Это делает код более модульным и защищенным.
* Наследование: Это возможность создания новых классов на основе существующих (родительских) классов. Новый класс, называемый дочерним, наследует свойства и методы родительского класса, что позволяет избежать дублирования кода и повторного использования функциональности.
* Полиморфизм: Это способность объекта использовать методы одного и того же имени для выполнения различных действий. Полиморфизм может быть достигнут через перегрузку методов (overloading) или переопределение методов (overriding).

===

## В чем разница между абстрактным классом и интерфейсом?

===

1. Интерфейс описывает только поведение. У него нет состояния. А у абстрактного класса состояние есть: он описывает и то, и другое. Абстрактный класс может содержать как абстрактные методы, так и конкретные методы, а также переменные экземпляра. Интерфейс может содержать только абстрактные методы (до Java 8), или также конкретные методы с реализацией (начиная с Java 8), а также константы, но не переменные экземпляра.
2. Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую связь. В то же время, один и тот же интерфейс могут реализовать классы, у которых вообще нет ничего общего.
3. Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса.
4. Интерфейсы - контракт, классы - общий тип.

===

## Что такое перегрузка и переопределение методов?

===

1. Перегрузка методов (method overloading):
    * Перегрузка методов позволяет создавать несколько методов с одинаковыми именами в одном классе, но с различными списками параметров.
    * Компилятор различает перегруженные методы по их сигнатурам (именам и типам параметров).
    * Методы, перегруженные в классе, могут иметь разные типы возвращаемых значений.
    * Перегрузка методов решает вопрос функционального перегружения, когда метод выполняет схожую операцию, но с разными типами данных.

2. Переопределение методов (method overriding):
    * Переопределение методов происходит, когда подкласс предоставляет реализацию метода, который уже определен в его суперклассе.
    * Подкласс может переопределить метод с тем же именем, списком параметров и типом возвращаемого значения.
    * Переопределенный метод в подклассе должен быть доступным для переопределения, т.е. он не может быть объявлен как final или static в суперклассе.
    * При вызове метода ссылающегося на объект суперкласса, но в действительности ссылается на объект подкласса, будет вызван метод, переопределенный в подклассе.

===

## Объясните концепцию инкапсуляции с примером в Java.

===

```java
public class Person {
    private String name; // Приватное поле, доступ к которому ограничен только внутри класса

    // Геттер для поля name, чтобы получить значение
    public String getName() {
        return name;
    }

    // Сеттер для поля name, чтобы установить значение
    public void setName(String newName) {
        // Здесь можно добавить дополнительную логику или проверки
        this.name = newName;
    }
}
```
В этом примере поле name является приватным, что означает, что оно доступно только внутри класса Person. Внешний код не имеет прямого доступа к этому полю. Вместо этого доступ к значению поля name можно получить через публичный метод getName(), а значение можно установить с помощью публичного метода setName().

Преимущества использования инкапсуляции:
* Безопасность: Инкапсуляция защищает данные объекта от непосредственного доступа и модификации, что помогает предотвратить нежелательные изменения и обеспечивает целостность данных.
* Управление изменениями: Изменение внутренней реализации класса (например, изменение имени поля) не приведет к необходимости изменения внешнего кода, который использует этот класс.
* Абстракция: Инкапсуляция позволяет предоставить простой интерфейс для работы с объектом, скрывая сложные детали его реализации.

===

## Что такое полиморфизм в контексте Java?

===

Полиморфизм в контексте Java - это способность объекта использовать методы с одинаковыми именами, но с различной реализацией, в зависимости от типа объекта, который его вызывает. Это позволяет программисту использовать единый интерфейс для работы с различными типами объектов, не заботясь о конкретной реализации каждого из них.

1. Полиморфизм подтипов (Subtype Polymorphism):
    * Это достигается с помощью наследования и переопределения методов в подклассах.
    * Когда метод вызывается на объекте суперкласса, который на самом деле ссылается на объект подкласса, будет выполнена версия метода из подкласса.
    * Полиморфизм подтипов обеспечивается использованием ключевого слова @Override, чтобы явно указать, что метод переопределен.

2. Параметрический полиморфизм (Parametric Polymorphism):
    * Это достигается с помощью обобщенных типов (generics) в Java.
    * Обобщенные методы и классы могут работать с различными типами данных без явного указания конкретного типа.
    * Параметрический полиморфизм позволяет написать универсальный код, который может быть использован с различными типами данных.

===

## Каковы основные различия между checked и unchecked исключениями?

===

1. Проверяемые (checked) исключения:
    * Это исключения, которые должны быть обработаны или объявлены в сигнатуре метода с помощью блока try-catch или оператора throws.
    * Проверяемые исключения включают в себя подклассы Exception, за исключением подклассов RuntimeException и их потомков.
    * Примеры проверяемых исключений включают IOException, SQLException и т.д.
    * Обработка проверяемых исключений обязательна на этапе компиляции, иначе код не будет скомпилирован.

2. Непроверяемые (unchecked) исключения:
    * Это исключения, которые не обязательно обрабатывать или объявлять в сигнатуре метода.
    * Непроверяемые исключения включают в себя подклассы RuntimeException и их потомков.
    * Примеры непроверяемых исключений включают NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException и т.д.
    * Обработка непроверяемых исключений не является обязательной на этапе компиляции. Однако, если исключение не обработано в коде, оно приведет к аварийному завершению программы (ошибке времени выполнения).

===

## Как работает механизм исключений в Java?

===

1. Выброс исключения (Throwing an Exception):
    * Когда возникает ошибка или иная непредвиденная ситуация в коде, создается объект исключения с помощью оператора throw.
    * Возможные причины для выброса исключений включают деление на ноль, обращение к несуществующему объекту, чтение данных из недоступных источников и т.д.
2. Перехват исключения (Catching an Exception):
    * Для обработки исключения используется блок try-catch. Код, который может вызвать исключение, помещается в блок try, а код для обработки исключения - в блок catch.
    * Когда исключение происходит в блоке try, управление передается соответствующему блоку catch для обработки.
3. Очистка ресурсов (Cleaning up Resources):
    * Блок finally может использоваться для выполнения кода, который должен быть выполнен независимо от того, возникло исключение или нет.
    * Этот блок часто используется для освобождения ресурсов, таких как закрытие файлов или соединений с базой данных.
4. Передача исключения (Throwing Exception Further):
    * Если блок catch не может обработать исключение, оно может быть снова выброшено с помощью оператора throw для передачи его вызывающему коду.
    * Это может быть полезно, когда исключение не может быть обработано в текущем контексте.

===

## Что такое Java Collections Framework? Перечислите основные интерфейсы и их реализации.

===

Java Collections Framework (JCF) - это набор классов и интерфейсов, предназначенных для удобного и эффективного управления и манипулирования коллекциями объектов в Java. Он предоставляет общий набор абстракций для работы с различными типами коллекций, такими как списки, множества, очереди и карты.

Основные интерфейсы в Java Collections Framework включают:
1. List:
    * Интерфейс List представляет собой упорядоченную коллекцию, которая позволяет дублирование элементов и поддерживает доступ к элементам по индексу.
    * Реализации: ArrayList, LinkedList, Vector.
2. Set:
    * Интерфейс Set представляет собой коллекцию, которая не содержит дубликатов элементов.
    * Реализации: HashSet, TreeSet, LinkedHashSet.
3. Queue:
    * Интерфейс Queue представляет собой коллекцию, которая используется для хранения элементов в порядке FIFO (первый вошел, первый вышел).
    * Реализации: LinkedList, PriorityQueue.
4. Map:
    * Интерфейс Map представляет собой отображение ключей на значения и не содержит дубликатов ключей.
    * Реализации: HashMap, TreeMap, LinkedHashMap.
5. Deque:
    * Интерфейс Deque представляет собой двустороннюю очередь, которая позволяет добавлять и удалять элементы как в начале, так и в конце коллекции.
    * Реализации: ArrayDeque, LinkedList.

===

## В чем разница между equals() и ==?

===

В Java оператор == используется для сравнения примитивных типов данных и для сравнения ссылок на объекты. Метод equals() вызывается на объектах и обычно переопределен в классах для сравнения значений или содержимого объектов.

Вот основные различия между equals() и ==:
1. Сравнение значений:
    * Оператор == сравнивает ссылки на объекты, а не их содержимое. Два объекта считаются равными только в том случае, если они указывают на один и тот же участок памяти.
    * Метод equals() по умолчанию выполняет такое же сравнение, как и оператор ==. Однако его можно переопределить в классе для выполнения сравнения значений объектов.
2. Переопределение:
    * Оператор == не может быть переопределен в классе, так как это языковая конструкция, а не метод.
    * Метод equals() может быть переопределен в классе для выполнения сравнения содержимого объектов в соответствии с логикой приложения. Обычно он сравнивает содержимое полей объектов.

===

## Объясните концепцию String Pool в Java.

===

Строковый пул (String Pool) в Java - это механизм для оптимизации использования памяти, который представляет собой специальное место в памяти, где хранятся уникальные строки (объекты класса String). Когда вы создаете новую строку в Java с помощью литерала или метода String.intern(), JVM проверяет, есть ли уже строка с таким значением в пуле строк. Если такая строка уже существует, то возвращается ссылка на нее, в противном случае создается новый объект String и помещается в пул строк.

Вот основные особенности и принципы работы строкового пула в Java:
1. Уникальность строк:
    * Строковый пул гарантирует, что каждая уникальная строка в программе будет представлена только одним объектом String. Это означает, что если две строки имеют одинаковое содержимое, они будут представлены одним и тем же объектом в пуле строк.
2. Создание строк с использованием литералов:
    * Когда вы создаете строку с помощью литерала (например, "hello"), JVM сначала проверяет, существует ли уже такая строка в пуле строк. Если строка уже существует, то возвращается ссылка на нее, иначе создается новый объект String и помещается в пул строк.
3. Метод intern():
    * Метод intern() используется для явного помещения строки в строковый пул. Если строка уже присутствует в пуле строк, то метод вернет ссылку на нее, в противном случае строка будет добавлена в пул и возвращена ссылка на новый объект String.

===

## Какие модификаторы доступа существуют в Java и что они означают?

===

1. public. Модификатор public обозначает, что класс, переменная или метод доступны из любого места, как внутри того же пакета, так и из других пакетов. Это самый открытый уровень доступа.

2. protectedю Модификатор protected означает, что класс, переменная или метод доступны внутри того же пакета, а также в подклассах (наследниках) данного класса, независимо от того, в каком пакете они находятся.

3. default (package-private). Если не указан модификатор доступа, то по умолчанию используется модификатор доступа "по пакету" (также известный как package-private). Это означает, что класс, переменная или метод доступны только внутри того же пакета.

4. private. Модификатор private означает, что класс, переменная или метод доступны только внутри того же класса, в котором они объявлены. Это самый ограниченный уровень доступа.

===

## Что такое статический контекст в Java и как он работает?

===


Статический контекст в Java связан с использованием статических элементов класса: статических переменных и статических методов. Когда вы объявляете переменную или метод как статический, они становятся частью статического контекста класса, а не его экземпляров (объектов).

1. Статические переменные:
    * Статические переменные принадлежат классу, а не конкретному экземпляру класса. Они создаются при загрузке класса в память и доступны для всех экземпляров этого класса.
    * Значение статической переменной общее для всех экземпляров класса.
    * Статические переменные обычно используются для хранения данных, которые должны быть общими для всех экземпляров класса, например, счетчики объектов или константы.

2. Статические методы:
    * Статические методы принадлежат классу, а не конкретному экземпляру класса. Они могут быть вызваны без создания объекта класса.
    * Статические методы могут обращаться только к другим статическим элементам класса и не имеют доступа к нестатическим (обычным) переменным и методам класса.

3. Загрузка в память:
    * Класс и его статические элементы загружаются в память JVM при первом обращении к классу (т.е. при создании первого объекта класса или вызове первого статического метода).

4. Общие данные и методы:
    * Статический контекст предоставляет общие данные и методы, которые доступны для всех экземпляров класса и могут быть использованы без создания объекта класса.

5. Ограничения:
    * Из-за своего общего характера использование статических элементов класса должно быть осторожным, чтобы не создавать глобальные состояния и избегать ухудшения читаемости и поддерживаемости кода.

===

## Какие циклы существуют в Java и в чем их особенности?

===

1. Цикл for:
    * Цикл for используется, когда количество повторений известно заранее.
    * Синтаксис:
    ```java
    for (инициализация; условие; выражение_обновления) {
        // тело цикла
    }
    ```
    * Переменная инициализации обычно используется для установки начального значения счетчика цикла, условие определяет, продолжать ли выполнение цикла, и выражение обновления обычно используется для увеличения счетчика.

2. Цикл while:
    * Цикл while используется, когда количество повторений неизвестно заранее и зависит от условия.
    * Синтаксис:
    ```java
    while (условие) {
        // тело цикла
    }
    ```
    * Условие проверяется перед каждой итерацией цикла. Если условие истинно, тело цикла выполняется.

3. Цикл do-while:
    * Цикл do-while похож на цикл while, но условие проверяется после выполнения тела цикла, что гарантирует, что тело цикла выполнится хотя бы один раз.
    * Синтаксис:
    ```java
    do {
        // тело цикла
    } while (условие);
    ```

4. Цикл foreach (Цикл for-each):
    * Цикл foreach используется для итерации по элементам массивов или коллекций без явного использования счетчика или индекса.
    * Синтаксис:
    ```java
    for (тип переменной : набор_данных) {
        // тело цикла
    }
    ```
    * Он автоматически перебирает каждый элемент в наборе данных, начиная с первого и до последнего.

===

## Что такое Java Virtual Machine и как она работает?

===

см. раздел JVM

===

## Каков жизненный цикл объекта в Java?

===

1. Создание (Creation):
    * На этом этапе вы создаете новый объект с помощью оператора new или других механизмов создания объектов (например, рефлексии).
    * При создании объекта выделяется память для его хранения, и вызывается конструктор класса для инициализации полей объекта.

2. Использование (Usage):
    * После создания объекта он может быть использован для выполнения различных операций в вашей программе.
    * Объект может быть передан в методы, изменен, использован для доступа к его полям и вызова его методов.

3. Сборка мусора (Garbage Collection):
    * В течение жизненного цикла объекта может наступить момент, когда объект больше не используется и на него нет ссылок из других частей программы. На этом этапе объект считается "мусором".
    * Сборщик мусора в Java периодически сканирует память и удаляет объекты, на которые больше нет ссылок, чтобы освободить память и предотвратить утечки памяти.
    * Когда объект подлежит сборке мусора, его финализирующий метод (если таковой есть) может быть вызван перед его фактическим удалением из памяти.

4. Уничтожение (Destruction):
    * На этом этапе объект полностью удаляется из памяти Java в результате сборки мусора. Память, выделенная под объект, освобождается для повторного использования.

===

## В чем разница между компиляцией и интерпретацией в контексте Java?

===

см. раздел JVM

===

## Что такое garbage collection в Java и как она работает?

===

см. раздел JVM

===

## Объясните концепцию сериализации и десериализации объектов.

===

Сериализация и десериализация - это процессы преобразования объектов Java в последовательность байтов для сохранения их в файле или передачи по сети, а затем обратного преобразования этих байтов обратно в объекты.

1. Сериализация:
    * Сериализация представляет собой процесс преобразования объекта Java в последовательность байтов. Это делается с помощью механизма сериализации Java, который автоматически сохраняет состояние объекта, включая значения его полей и иерархию классов.
    * Чтобы объект мог быть сериализован, его класс должен реализовать интерфейс Serializable. Этот интерфейс не содержит ни одного метода и является просто маркерным интерфейсом, который говорит JVM о том, что объект может быть сериализован.
    * Процесс сериализации выполняется с помощью класса ObjectOutputStream, который записывает объект в поток вывода данных, который затем может быть направлен в файл, сетевое соединение и т. д.
    * Пример:
    ```java
    public class SerializationExample {
        public static void main(String[] args) throws IOException {
            // Создание объекта для сериализации
            MyClass obj = new MyClass("Hello, World!");

            // Сериализация объекта в файл
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("object.ser"));
            out.writeObject(obj);
            out.close();
        }
    }
    ```

2. Десериализация:
    * Десериализация - это обратный процесс, при котором последовательность байтов, представляющая сериализованный объект, преобразуется обратно в объект Java.
    * Для десериализации объекта его класс должен иметь открытый конструктор без параметров, чтобы объект мог быть создан с помощью рефлексии.
    * Процесс десериализации выполняется с помощью класса ObjectInputStream, который читает последовательность байтов из потока ввода данных и восстанавливает объекты, сохраненные в этой последовательности.
    * Пример:
    ```java
    public class DeserializationExample {
        public static void main(String[] args) throws IOException, ClassNotFoundException {
            // Десериализация объекта из файла
            ObjectInputStream in = new ObjectInputStream(new FileInputStream("object.ser"));
            MyClass obj = (MyClass) in.readObject();
            in.close();

            // Использование восстановленного объекта
            System.out.println(obj.getMessage()); // Output: Hello, World!
        }
    }
    ```

===

## Что такое рефлексия и как она используется в Java?

===

Рефлексия в Java - это механизм, который позволяет программам получать информацию о типах объектов во время выполнения (runtime) и манипулировать ими. С помощью рефлексии программы могут динамически получать доступ к полям классов, методам, конструкторам, а также изменять их значения и вызывать методы, не зная этих деталей на этапе компиляции.

Вот некоторые способы использования рефлексии в Java:
* Получение информации о классе. Рефлексия позволяет получить информацию о полях, методах, конструкторах, аннотациях и других деталях класса во время выполнения.
* Динамическое создание объектов. С помощью рефлексии можно создавать объекты классов, даже если их тип неизвестен до момента выполнения.
* Доступ к полям и методам. Рефлексия позволяет получать доступ к значениям полей и вызывать методы объектов динамически во время выполнения.
* Манипуляция с модификаторами доступа. Рефлексия позволяет изменять доступность полей и методов объектов, даже если они были объявлены как private.
* Работа с массивами и обобщенными типами. Рефлексия обеспечивает доступ к информации о массивах и обобщенных типах, включая их состав и параметры.

===

## Какие основные нововведения были введены в последних версиях Java (например, Java 8, 11 и 17)?

===

1. Java 8:
    * Введение лямбда-выражений и функциональных интерфейсов, облегчающих работу с функциональным стилем программирования.
    * Появление потоков (Streams) и API для работы с ними (java.util.stream), обеспечивающих более удобную и эффективную обработку коллекций данных.
    * Добавление интерфейса java.util.Optional для более безопасной работы с возможно отсутствующими значениями.
    * Методы по умолчанию (default methods), позволяющие добавлять новые методы в существующие интерфейсы без их реализации во всех классах-наследниках.

2. Java 9:
    * Введение модульной системы Java (Project Jigsaw), которая позволяет организовать код в модули для лучшей изоляции и управляемости зависимостей.
    * Модульная платформа Java (jmod), предоставляющая инструменты для создания и управления модулями.
    * Метод ofNullable() в классе java.util.Optional для создания Optional объектов с возможно отсутствующим значением.

3. Java 10:
    * Введение типа данных var (локальные переменные с неявным типом), упрощающего написание кода и повышающего его читаемость.
    * Внедрение метода java.util.Optional.orElseThrow() для возбуждения исключения, если Optional объект содержит отсутствующее значение.

4. Java 11:
    * Включение в стандартную библиотеку JDK модуля java.net.http для работы с HTTP-запросами и ответами в стиле Reactive Streams.
    * Добавление метода String.stripIndent() для удаления отступов из многострочных строк.

5. Java 12:
    * Введение в JDK усовершенствований для улучшения метрики памяти и производительности.

6. Java 13:
    * Включение в JDK улучшений для работы с строками, включая метод String.indent() для добавления отступов в многострочные строки.
    * Внедрение класса java.text для улучшения работы с форматированным текстом.

7. Java 14:
    * Введение в JDK платформенной фичи Switch Expressions, предоставляющей удобный способ для обработки множественных вариантов в switch-выражениях.

8. Java 15:
    * Включение в JDK улучшений для управления памятью, включая реализацию Z Garbage Collector.

9. Java 16:
    * Введение в JDK улучшений для работы с классами и записью информации о классах.

10. Java 17:
    Включение в JDK улучшений для повышения производительности, безопасности и удобства использования, а также поддержка для новых языковых и технологических функций.

https://habr.com/ru/articles/719744/

===
