# Multithreading

## Что такое многопоточность и зачем она нужна?

===


Многопоточность в программировании означает способность программы выполнять несколько потоков выполнения одновременно. Поток представляет собой последовательность инструкций, которые выполняются процессором. Многопоточность позволяет программе разделять нагрузку между несколькими ядрами процессора или даже между несколькими процессорами.

Вот несколько причин, по которым многопоточность может быть полезной:
1. Увеличение производительности: Разделение задач на несколько потоков позволяет использовать ресурсы процессора более эффективно. Это особенно полезно в многоядерных или многопроцессорных системах.
2. Улучшение отзывчивости: Параллельное выполнение задач может сделать программу более отзывчивой, поскольку длительные операции могут выполняться параллельно с другими задачами.
3. Решение проблем блокировок: Многопоточность может помочь избежать блокировок, когда одна часть программы ожидает завершения какой-то операции, блокируя другие части программы. Путем разделения этих операций на разные потоки можно избежать подобных блокировок.
4. Разделение задач: Разделение задач на отдельные потоки может упростить структуру программы и сделать код более понятным и модульным.

В Java многопоточность реализуется с использованием классов из пакета java.lang.Thread или путем реализации интерфейса java.lang.Runnable или расширения класса java.lang.Thread. Кроме того, начиная с версии Java 5, был добавлен пакет java.util.concurrent, который предоставляет более высокоуровневые средства для работы с потоками и синхронизацией.

===

## Как создать поток в Java?

===


В Java есть несколько способов создать поток. Вот два основных способа:

1. Создание класса, расширяющего Thread. Вы можете создать новый класс, который наследует класс Thread и переопределить метод run() для определения задачи, которую вы хотите выполнить в потоке. Затем вы можете создать экземпляр этого класса и вызвать метод start(), чтобы запустить новый поток.
2. Реализация интерфейса Runnable.Вы также можете создать класс, который реализует интерфейс Runnable, который содержит метод run(). Затем создайте экземпляр класса Thread, передавая ваш объект Runnable в качестве параметра конструктора. Затем вызовите метод start() для запуска потока.

===

## В чем разница между процессом и потоком?

===

Процесс:
* Процесс представляет собой экземпляр выполняющейся программы на компьютере.
* Каждый процесс имеет своё собственное адресное пространство памяти, в котором хранятся данные, код и ресурсы, необходимые для выполнения программы.
* Процессы являются изолированными друг от друга и не могут напрямую взаимодействовать с памятью или ресурсами других процессов без использования механизмов межпроцессного взаимодействия (IPC).
* Процесс может содержать один или несколько потоков.

Поток:
* Поток - это отдельная последовательность инструкций, которая выполняется внутри процесса.
* В одном процессе может существовать несколько параллельно выполняющихся потоков, каждый из которых имеет свой собственный стек вызовов и может выполняться независимо от других потоков в пределах процесса.
* Потоки в пределах одного процесса могут совместно использовать ресурсы этого процесса, такие как память или файлы, без необходимости использования механизмов межпроцессного взаимодействия.
* Потоки обычно используются для организации параллельного выполнения задач и повышения производительности программ.

===

## Объясните разницу между методами start() и run() в классе Thread.

===

Метод start():
* Когда вызывается метод start(), создается новый поток выполнения, и метод run() этого потока вызывается непосредственно в отдельном потоке.
* Этот метод запускает новый поток, который начнет выполнение параллельно с другими потоками в программе.
* Вызов start() запускает все необходимые процессы для управления потоком, включая выделение ресурсов, управление стеком вызовов и т. д.

Метод run():
* Метод run() содержит код, который будет выполнен в потоке. Однако, если вызвать run() напрямую, код будет выполнен в текущем потоке, а не в новом потоке.
* Вызов run() напрямую просто вызывает метод run() объекта Thread в текущем потоке, и выполнение кода происходит последовательно, без создания нового потока.

===

## Что такое синхронизация и почему она важна в многопоточных приложениях?

===

Синхронизация в многопоточных приложениях — это механизм контроля доступа к общим ресурсам или критическим участкам кода для предотвращения конфликтов и обеспечения правильного выполнения программы. Когда несколько потоков обращаются к общему ресурсу или выполняют критические операции, несинхронизированный доступ может привести к непредсказуемым результатам, таким как состояние гонки, в котором результат зависит от порядка выполнения потоков.

Вот несколько причин, почему синхронизация важна в многопоточных приложениях:
* Предотвращение состояния гонки (Race Conditions): Состояние гонки возникает, когда несколько потоков пытаются одновременно читать и записывать общие данные без синхронизации. Это может привести к непредсказуемому поведению программы и ошибкам в данных.
* Обеспечение согласованности данных: Синхронизация помогает обеспечить согласованность данных в многопоточной среде, гарантируя, что операции чтения и записи будут выполняться в правильном порядке.
* Избежание блокировок: Синхронизация также помогает избежать блокировок, когда один поток блокирует общий ресурс, не позволяя другим потокам получить к нему доступ. Правильно спроектированная синхронизация может помочь избежать таких ситуаций.
* Обеспечение атомарности операций: Синхронизация позволяет выполнять группу операций как единое атомарное действие, что может быть критически важно для поддержания целостности данных.

===

## Как работает механизм synchronized в Java?

===

Механизм synchronized в Java позволяет создавать критические секции кода, которые могут быть выполнены только одним потоком одновременно. Это помогает обеспечить синхронизацию доступа к общим ресурсам или критическим участкам кода в многопоточных приложениях.



===

## Что такое взаимная блокировка (deadlock) и как ее избежать?

===

В Java есть два способа использования механизма synchronized:
* Синхронизация метода. Вы можете объявить метод как synchronized, чтобы гарантировать, что только один поток может выполнить этот метод для данного объекта одновременно. Когда поток вызывает synchronized метод, он автоматически захватывает монитор этого объекта и освобождает его при завершении выполнения метода.
* Синхронизированный блок. Вы можете создать синхронизированный блок кода, используя ключевое слово synchronized, чтобы захватить монитор определенного объекта или класса. Это позволяет контролировать доступ к критической секции кода более гибко.

Механизм synchronized обеспечивает мониторинг доступа к общим ресурсам и предотвращает состояния гонки, блокировки и другие проблемы синхронизации в многопоточных приложениях. Однако он может привести к снижению производительности, если не используется правильно, поэтому необходимо аккуратно использовать его в критических участках кода, чтобы избежать излишней блокировки.

===

## Что такое гонка за ресурсами (race condition)?

===


Гонка за ресурсами (англ. Race Condition) - это состояние, возникающее в многопоточных программных средах, когда результаты выполнения программы зависят от порядка выполнения инструкций или потоков. Это явление возникает, когда несколько потоков пытаются одновременно получить доступ к общему ресурсу или переменной и изменить ее значение без синхронизации.

===

## Объясните, что такое volatile переменные.

===

В Java ключевое слово volatile используется для объявления переменных, чтобы указать, что их значение может быть изменено несколькими потоками. Использование volatile гарантирует, что операции чтения и записи для таких переменных будут атомарными и видимыми для всех потоков.

Вот основные аспекты volatile переменных:
1. Атомарность операций чтения и записи: При использовании volatile гарантируется, что операции чтения и записи переменной будут атомарными. Это означает, что если один поток записывает значение в volatile переменную, то все остальные потоки увидят это значение в следующем чтении. Без volatile операции чтения и записи могут быть разделены между разными ядрами процессора, что может привести к непредсказуемым результатам.
2. Синхронизация потоков по кешу: При использовании volatile переменные не кэшируются в локальных кешах потоков, а все операции с ними напрямую влияют на основную память. Это гарантирует, что изменения, внесенные одним потоком, будут видны всем остальным потокам сразу после записи.
3. Отсутствие блокировок: В отличие от блокировок, volatile не создает блокировок на доступ к переменной. Это означает, что доступ к volatile переменной может быть более эффективным в сравнении с использованием блокировок, но volatile не подходит для сценариев, требующих сложной синхронизации или атомарных операций над несколькими переменными.

===

## Что такое wait() и notify() в контексте многопоточности?

===

Методы wait() и notify() являются частью механизма в Java для синхронизации между потоками и реализации механизмов ожидания-уведомления (wait-notify).

Метод wait():
* Метод wait() вызывается на объекте и заставляет текущий поток ожидать до тех пор, пока другой поток не вызовет метод notify() или notifyAll() на том же объекте.
* При вызове wait(), текущий поток встает в режим ожидания и освобождает монитор объекта, на котором вызван метод wait(). Это позволяет другим потокам получить доступ к этому объекту.
* Поток будет ожидать, пока другой поток не вызовет метод notify() или notifyAll() на том же объекте или пока не истечет время ожидания, если оно было указано.

Методы notify() и notifyAll():
* Метод notify() используется для уведомления одного из потоков, ожидающих на объекте, на котором был вызван метод wait(). Если на объекте есть несколько потоков ожидания, то будет выбран один из них (хотя не определено, какой именно).
* Метод notifyAll() уведомляет все потоки, ожидающие на объекте, на котором был вызван метод wait().
* После того как поток вызвал notify() или notifyAll(), один из ожидающих потоков будет выбран для возобновления выполнения, однако это происходит не сразу, а только после того, как поток, вызвавший notify(), освободит монитор объекта.

===

## Что такое ExecutorService и как он используется?

===

ExecutorService в Java представляет собой высокоуровневый API, предназначенный для выполнения и управления задачами в многопоточной среде. Он предоставляет удобный способ создания и управления пулом потоков, а также выполнения асинхронных задач.

Основные концепции ExecutorService:
1. Пул потоков (Thread Pool): ExecutorService создает пул потоков для выполнения задач. Вместо создания и запуска новых потоков для каждой задачи он повторно использует существующие потоки, что снижает накладные расходы на создание и уничтожение потоков.
2. Очередь задач (Task Queue): Задачи, передаваемые ExecutorService, помещаются в очередь, откуда потоки пула выбирают и выполняют их по мере доступности.

===

## Какое назначение у ReentrantLock?

===


ReentrantLock в Java представляет собой механизм блокировки (lock), который обеспечивает возможность блокировать и разблокировать код для доступа к общим ресурсам в многопоточной среде. Он работает подобно ключевому слову synchronized, но обладает дополнительными возможностями и гибкостью.

Основное назначение ReentrantLock заключается в обеспечении взаимного исключения (mutual exclusion) для критических секций кода, то есть позволяет только одному потоку выполнять критический код в определенный момент времени, предотвращая тем самым возникновение состояний гонки (race conditions).

Основные преимущества ReentrantLock перед использованием synchronized включают:
* Попытки захвата блокировки с тайм-аутом: Метод tryLock() позволяет попытаться захватить блокировку с указанием максимального времени ожидания. Это позволяет избежать блокировки потока навсегда, если блокировка недоступна.
* Прерываемые операции блокировки: Метод lockInterruptibly() позволяет потоку быть прерванным (interrupted), если он находится в состоянии ожидания захвата блокировки.
* Условные блокировки: Механизм условных блокировок (Condition) позволяет потокам ожидать определенного условия в критической секции кода.
* Нестрогие порядки блокировок: В отличие от synchronized, ReentrantLock может использоваться с нестрогим порядком блокировок, что позволяет избежать потенциальных проблем с взаимной блокировкой (deadlock).

===

## Что такое условные переменные (Condition)?

===

Условные переменные (Condition) являются частью пакета java.util.concurrent в Java и представляют собой механизм синхронизации, который позволяет потокам ждать определенного условия. Они часто используются в многопоточных приложениях для координации работы потоков и обмена информацией между ними.

В Java условные переменные работают в сочетании с объектами типа Lock (замок). Основная идея заключается в том, что потоки могут ждать определенного условия, используя методы await() и signal() (или signalAll()).

Вот как это обычно работает:
1. Поток захватывает замок.
2. Проверяется условие. Если условие истинно, поток продолжает выполнение, в противном случае он вызывает await() и освобождает замок.
3. Пока поток ждет, он блокируется и не потребляет процессорное время.
4. Другой поток, имеющий доступ к тому же замку, может выполнить действия, которые изменят состояние, на котором зависит условие.
5. После изменения состояния поток, вызвавший await(), может быть оповещен (через signal() или signalAll()) о том, что условие, возможно, изменилось.
6. После получения оповещения поток снова проверяет условие и, если оно истинно, продолжает выполнение. В противном случае, он снова вступает в состояние ожидания. 

Это позволяет эффективно координировать действия между потоками, особенно когда один поток производит какую-то работу, а другие должны ждать определенного состояния, чтобы продолжить свое выполнение.

===

## В чем разница между параллелизмом и конкурентностью?

===

Параллелизм (Parallelism):
* Параллелизм относится к одновременному выполнению нескольких задач. Эти задачи могут выполняться на разных процессорах или ядрах процессора одновременно.
* Основная идея параллелизма состоит в том, чтобы разделить задачу на несколько подзадач и выполнять их параллельно, чтобы ускорить выполнение программы.
* Параллелизм часто используется для улучшения производительности, особенно на многоядерных или многопроцессорных системах.

Конкурентность (Concurrency):
* Конкурентность относится к координации выполнения нескольких задач, которые могут работать одновременно, но не обязательно параллельно.
* Задачи выполняются в перекрывающихся временных интервалах, и они могут обмениваться ресурсами или конкурировать за доступ к общим ресурсам.
* Основная идея конкурентности состоит в создании приложений, которые могут обрабатывать несколько задач одновременно, даже если у них есть ограниченные ресурсы, такие как один процессор.

===

## Что такое потокобезопасность (thread safety) и как ее обеспечить?

===

Потокобезопасность (thread safety) - это свойство программы, при котором ее корректность сохраняется при одновременном выполнении нескольких потоков. В многопоточных приложениях, где несколько потоков могут одновременно обращаться к общим ресурсам или данным, потокобезопасность играет ключевую роль для предотвращения состояний гонки, искажения данных и других непредсказуемых результатов.

Обеспечить потокобезопасность можно различными способами:

Использование синхронизации:
* Синхронизация позволяет контролировать доступ к общим ресурсам или участкам кода, гарантируя, что только один поток может выполнять критическую секцию кода в определенный момент времени.
* В Java синхронизация может быть достигнута с помощью ключевого слова synchronized, мониторов объектов (synchronized блоков), Lock интерфейса и других механизмов.

Использование атомарных операций:
* Атомарные операции гарантируют, что операция чтения и записи выполняется как единое неделимое действие, что исключает состояния гонки.
* В Java атомарные операции предоставляются классами из пакета java.util.concurrent.atomic, такими как AtomicInteger, AtomicBoolean, и другими.

Использование неизменяемости (Immutability):
* Неизменяемые объекты не могут быть изменены после создания, что делает их безопасными для использования в многопоточной среде.
* Поскольку неизменяемые объекты не могут быть изменены, они не требуют синхронизации при доступе к ним из нескольких потоков.

Использование потокобезопасных коллекций:
* В Java есть коллекции из пакета java.util.concurrent, которые обеспечивают потокобезопасность при доступе из нескольких потоков.
* Например, ConcurrentHashMap, CopyOnWriteArrayList и другие.

Анализ и разработка безопасных алгоритмов:
* Иногда потокобезопасность может быть обеспечена путем разработки безопасных алгоритмов, которые избегают состояний гонки и других проблем синхронизации.

===

## Объясните модель памяти Java (Java Memory Model).

===

Модель памяти Java (Java Memory Model, JMM) описывает, как потоки в Java взаимодействуют с памятью при выполнении операций чтения и записи. Это важно для правильной синхронизации и обеспечения корректной работы многопоточных программ.

Основные аспекты модели памяти Java включают в себя:
* Поддержание видимости изменений: Одним из ключевых аспектов JMM является гарантия того, что изменения, внесенные одним потоком в разделяемые переменные, становятся видимыми другим потокам в правильном порядке.
* Упорядочивание операций: JMM устанавливает определенные правила относительно порядка выполнения операций чтения и записи для каждого потока. Это важно для предотвращения ошибок, связанных с гонками данных и упорядочиванием инструкций внутри каждого потока.
* Синхронизация потоков: JMM предоставляет механизмы синхронизации, такие как блокировки, взаимные исключения и ключевые слова synchronized и volatile, для обеспечения правильной синхронизации между потоками.
* Потоковые видимости: JMM определяет, какие изменения могут быть видны другим потокам в зависимости от того, в какой момент потоки синхронизируются или синхронизируют доступ к разделяемым переменным.
* Happens-Before отношения: Это понятие в JMM определяет, когда одно действие должно быть гарантированно выполнено перед другим. Например, операция записи в переменную должна "случиться раньше", чем операция чтения этой переменной в другом потоке.
* Final-поле семантика: Для переменных, помеченных ключевым словом final, JMM предоставляет дополнительные гарантии видимости и порядка их инициализации.

===

## Как реализовать потокобезопасный синглтон?

===

1. Если хотим простое решение без ленивой инициализации - статическое поле
    ```java
    public class Singleton {
        public static final Singleton INSTANCE = new Singleton();
    }
    ```
2. Если хотим ленивую реализацию - double-checked locking + volatile
    ```java
    public class Singleton {
            private static volatile Singleton instance;
        
            public static Singleton getInstance() {
            Singleton localInstance = instance;
            if (localInstance == null) {
                synchronized (Singleton.class) {
                    localInstance = instance;
                    if (localInstance == null) {
                        instance = localInstance = new Singleton();
                    }
                }
            }
            return localInstance;
        }
    }
    ```

===

## Какие инструменты Java используются для работы с многопоточностью?

===

1. Классы java.lang.Thread и java.lang.Runnable: Эти классы являются базовыми инструментами для создания потоков выполнения в Java. Вы можете наследовать класс Thread или реализовать интерфейс Runnable для создания потоков.

2. java.util.concurrent.Executor и java.util.concurrent.ExecutorService: Эти интерфейсы предоставляют абстракцию над управлением потоками выполнения. Executor позволяет выполнить задачу асинхронно, а ExecutorService обеспечивает управление жизненным циклом потоков.

3. java.util.concurrent.ConcurrentHashMap: Это реализация интерфейса Map, которая обеспечивает потокобезопасное чтение и запись. Она предоставляет высокую производительность при параллельном доступе к элементам.

4. java.util.concurrent.locks.Lock и java.util.concurrent.locks.ReentrantLock: Эти классы предоставляют возможность блокировки ресурсов для обеспечения атомарного выполнения операций в многопоточной среде.

5. java.util.concurrent.atomic.AtomicInteger и другие классы из пакета java.util.concurrent.atomic: Эти классы предоставляют атомарные операции над примитивными типами данных. Они обеспечивают безопасный доступ к общим данным из нескольких потоков.

6. java.util.concurrent.CountDownLatch и java.util.concurrent.CyclicBarrier: Эти классы предоставляют средства для синхронизации выполнения нескольких потоков. CountDownLatch позволяет одному потоку ожидать завершения выполнения нескольких других потоков, а CyclicBarrier позволяет нескольким потокам ожидать друг друга, прежде чем продолжить выполнение.

7. java.util.concurrent.Future и java.util.concurrent.FutureTask: Эти классы представляют результат асинхронной операции. Они позволяют получить результат выполнения потока или задачи в будущем.

===

## Что такое ThreadLocal и для чего он используется?

===

ThreadLocal - это класс в Java, который предоставляет возможность создания переменных, связанных с потоком выполнения. Каждый поток, использующий ThreadLocal, имеет свою собственную копию переменной, хранящейся в ThreadLocal. Это означает, что каждый поток может читать и записывать свою собственную копию переменной без возможности доступа других потоков к ней.

ThreadLocal обычно используется в ситуациях, когда вам нужно хранить данные, которые должны быть доступны только в рамках одного потока. Например:
1. Сохранение контекста потока: Вы можете использовать ThreadLocal, чтобы сохранить контекст (например, пользовательские данные), которые должны быть доступны только в рамках определенного потока выполнения.
2. Избегание гонок данных: Используя ThreadLocal, вы можете избежать гонок данных, когда несколько потоков пытаются обновить одну и ту же переменную.
3. Управление транзакциями: В некоторых приложениях требуется управление транзакциями на уровне потока. ThreadLocal может использоваться для хранения информации о текущей транзакции, связанной с каждым потоком.

===

## Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.

===

Параллельные операции:
* Collections.synchronizedMap(new HashMap()): Хотя это обеспечивает потокобезопасный доступ к HashMap, все операции на мапе выполняются последовательно. То есть при вызове любого метода, например, get(), другие потоки будут заблокированы до тех пор, пока текущий метод не завершится.
* ConcurrentHashMap: Предоставляет более высокую степень параллелизма. Он разделяет мапу на сегменты, и операции чтения могут выполняться параллельно с операциями записи.

Производительность:
* Collections.synchronizedMap(new HashMap()): Использование синхронизации может привести к проблемам с производительностью в случае, когда много потоков читают и записывают данные одновременно из-за блокировок.
* ConcurrentHashMap: Эффективен в сценариях, когда много потоков выполняют операции чтения и записи одновременно, благодаря своей внутренней структуре и возможности параллельной работы.

Итерация:
* Collections.synchronizedMap(new HashMap()): Требует внешней синхронизации при итерации по мапе, чтобы избежать ConcurrentModificationException.
* ConcurrentHashMap: Позволяет безопасно итерироваться по мапе, не вызывая исключений.

Устаревший подход:
* Collections.synchronizedMap(new HashMap()): Этот подход к обеспечению потокобезопасности коллекций считается устаревшим в сравнении с новыми коллекциями из пакета java.util.concurrent, такими как ConcurrentHashMap.
* ConcurrentHashMap: Является более современным и предпочтительным вариантом для работы с многопоточными сценариями.

===

## Что такое кооперативная многозадачность и она ли ли в Java. Если да, то какие преимущества. Если нет, то какая тогда в Java?

===

Кооперативная многозадачность (cooperative multitasking) - это метод организации многозадачности, в котором каждая выполняемая задача активно передает управление другим задачам. В такой модели выполнение каждой задачи (или потока) зависит от сотрудничества этой задачи с другими задачами или с системным планировщиком.

Принцип кооперативной многозадачности подразумевает, что каждая задача должна регулярно освобождать процессорное время, чтобы другие задачи могли выполниться. Если задача продолжает выполняться без передачи управления, это может привести к блокировке или "зависанию" всей системы.

В контексте Java можно сказать, что кооперативная многозадачность не является основным механизмом управления потоками в языке. В Java используется преимущественно прерывание многозадачности (preemptive multitasking), где управление потоками осуществляется с помощью системного планировщика. Системный планировщик периодически переключает контекст выполнения между потоками в соответствии с их приоритетами и состоянием. Это позволяет избежать ситуаций, когда один поток может заблокировать выполнение других потоков.

В java многозадачность на основе потоков

===

## Что такое "зеленый потоки" и они ли ли в Java

===

"Зелёные потоки" (Green Threads), также известные как пользовательские потоки или легковесные потоки, представляют собой механизм управления потоками выполнения, который реализуется на уровне пользовательского пространства (user-space), а не на уровне ядра операционной системы.

В контексте Java, виртуальная машина Java (JVM) может использовать "зелёные потоки" в качестве альтернативы нативным потокам операционной системы. Такие потоки называются также "виртуальными потоками" или "потоками на уровне языка".

Вместо создания отдельного потока на уровне операционной системы для каждого потока выполнения Java-программы, JVM может создавать и управлять "зелёными потоками" внутри процесса Java. Это позволяет более гибко использовать ресурсы системы и обеспечивает более быстрое создание и переключение потоков.

Однако стоит отметить, что современные версии JVM, такие как HotSpot JVM, по умолчанию используют нативные потоки операционной системы для реализации потоков выполнения Java. Это происходит из-за преимуществ нативных потоков в отношении масштабируемости и эффективности.

Таким образом, хотя "зелёные потоки" могут использоваться в некоторых средах выполнения Java или в различных реализациях JVM, они не являются стандартным механизмом для управления потоками в современных версиях Java.

===

## Различия в интерфейсах Runnable и Callable

===

Методы:
* Интерфейс Runnable имеет единственный метод void run(), который не возвращает результат и не генерирует проверяемые исключения. Задача, представленная интерфейсом Runnable, не может выбросить проверяемое исключение.
* Интерфейс Callable имеет единственный метод V call() throws Exception, который возвращает результат выполнения задачи и может генерировать проверяемые исключения. Метод call() аналогичен методу run(), но может возвращать значение и генерировать исключения.

Возвращаемое значение:
* Метод run() возвращает void, поэтому задачи, реализующие интерфейс Runnable, не могут возвращать результат своей работы.
* Метод call() возвращает объект типа V (обобщенный тип), где V - тип результата выполнения задачи.

Генерируемые исключения:
* Метод run() не объявляет генерируемые исключения, поэтому задачи, реализующие интерфейс Runnable, не могут генерировать проверяемые исключения.
* Метод call() объявляет throws Exception, что позволяет задачам, реализующим интерфейс Callable, генерировать проверяемые исключения.

Использование в среде исполнения:
* Объекты, реализующие интерфейс Runnable, обычно используются вместе с классом Thread, который выполняет их метод run() в отдельном потоке.
* Объекты, реализующие интерфейс Callable, обычно используются вместе с ExecutorService или другими средствами планирования задач для выполнения в параллельных потоках. ExecutorService может возвращать Future для получения результата выполнения задачи, представленной интерфейсом Callable.

===

## Что происходит при вызове Thread.interrupt()

===

При вызове метода Thread.interrupt() происходит установка флага прерывания для данного потока. Это означает, что потоку отправляется сигнал о прерывании, который может быть обработан.

Однако сам вызов interrupt() не останавливает непосредственно выполнение потока. Вместо этого он устанавливает флаг прерывания, который поток может проверить периодически в своем коде.

Если поток находится в состоянии ожидания (например, при вызове методов Thread.sleep(), Object.wait(), Thread.join()), то вызов interrupt() приведет к генерации исключения InterruptedException, что может привести к выходу из состояния ожидания и дальнейшей обработке сигнала прерывания.

Если поток выполняет вычислительную работу, то он должен периодически проверять состояние флага прерывания с помощью метода Thread.isInterrupted(). При обнаружении установленного флага прерывания поток может завершить свою работу или выполнить какие-то действия для корректной обработки сигнала прерывания.

Важно отметить, что вызов interrupt() не гарантирует немедленного прерывания выполнения потока. Реакция потока на сигнал прерывания зависит от его собственной логики выполнения и способа обработки сигнала прерывания в коде потока.

===

## Что такое "monitor"?

===

"monitor" - это абстрактный концепт, используемый для обеспечения синхронизации доступа к общим ресурсам между потоками.

Концепция монитора была впервые предложена Эдсгером Дейкстрой в 1968 году и стала основой для разработки механизмов синхронизации во многих языках программирования, включая Java.

В Java монитор представлен внутренним объектом, связанным с каждым объектом. Каждый объект имеет свой монитор, который может быть захвачен одним потоком в любой момент времени. Когда поток захватывает монитор объекта, он блокирует доступ к этому объекту для других потоков, пока монитор не будет освобожден.

Методы и блоки, объявленные с модификатором synchronized в Java, используют монитор для обеспечения синхронизации доступа к общим ресурсам. При входе в синхронизированный блок или метод поток автоматически захватывает монитор объекта, а при выходе из блока или метода монитор освобождается.

===

## Что такое "private mutex"?

===

Термин "private mutex" обычно относится к ситуации, когда у каждого потока есть свой собственный мьютекс (блокировка), который используется для синхронизации доступа к общим ресурсам. Этот подход иногда используется в многопоточном программировании, когда каждый поток имеет доступ к определенным данным и не должен блокироваться другими потоками, имеющими доступ к другим данным.

Использование "private mutex" может быть полезным в ситуациях, когда каждый поток работает с независимыми наборами данных или когда работа с общими данными не требует блокировки доступа для других потоков. Это позволяет уменьшить взаимное исключение (mutex contention) между потоками и повысить параллелизм выполнения.

Примером использования "private mutex" может быть ситуация, когда каждый поток обрабатывает отдельный элемент в массиве или работает с отдельным списком. В таком случае каждый поток может использовать свой собственный мьютекс для синхронизации доступа к своему элементу или списку, что позволяет избежать конфликтов с другими потоками, работающими с другими элементами или списками.

В общем случае, использование "private mutex" может улучшить производительность и масштабируемость многопоточных приложений за счет уменьшения конкуренции за общие ресурсы. Однако важно тщательно проектировать и тестировать приложение при использовании "private mutex", чтобы убедиться в корректности его работы и отсутствии состояний гонки и других конкурентных проблем.

===

## Что такое ordering, visibility, atomicity, happend-before, mutual exclusion. Показать на примерах volatile, AtomicInteger, synchronize — что из вышеперечисленного списка присутствует и при каких вариантах использования.

===

1. Ordering (Порядок выполнения):
    * Определение: Это концепция, описывающая порядок выполнения инструкций в многопоточной среде. Не все операции будут выполняться в том порядке, в котором они написаны в коде из-за оптимизаций компилятора, аппаратных особенностей и других факторов.
    * Пример: Использование volatile позволяет гарантировать отсутствие перестановки операций чтения и записи с переменной, что обеспечивает нужный порядок выполнения операций.

2. Visibility (Видимость):
   * Определение: Это свойство, которое гарантирует, что изменения, внесенные одним потоком в общую память, будут видны другим потокам.
   * Пример: Использование volatile обеспечивает видимость изменений переменной между потоками.

3. Atomicity (Атомарность):
   * Определение: Это свойство операции, которое гарантирует, что она будет выполнена целиком, без промежуточных состояний, и никакой другой поток не сможет увидеть операцию в недопустимом промежуточном состоянии.
   * Пример: Класс AtomicInteger обеспечивает атомарные операции инкремента, декремента и обмена для целочисленных значений.

4. Happens-before (Предшествие):
   * Определение: Это отношение, которое гарантирует, что одно событие произошло до другого в многопоточной среде.
   * Пример: Синхронизация с помощью synchronized или volatile создает отношение "happens-before" между событиями чтения и записи.

5. Mutual Exclusion (Взаимное исключение):
   * Определение: Это концепция, которая гарантирует, что только один поток одновременно имеет доступ к общему ресурсу.
   * Пример: Использование synchronized обеспечивает взаимное исключение, предотвращая доступ нескольких потоков к критической секции кода одновременно.

===

## Какие проблемы многопоточности вы встречали и как их решали?

===



===

## Назовите отличия synchronize{} и ReentrantLock.

===

Гибкость:
* ReentrantLock обеспечивает большую гибкость по сравнению с synchronized. Он позволяет более точно управлять блокировками, такими как установка таймаута блокировки, попытка блокировки без ожидания (tryLock()) и возможность использования множественных условных переменных (Condition).
* synchronized, с другой стороны, является более простым и удобным в использовании, но предлагает меньше функциональности.

Видимость кода:
* Использование ReentrantLock явно показывает, где начинается и заканчивается критическая секция блокировки, так как блокировка и разблокировка выполняются явно вызовом методов lock() и unlock().
* synchronized, с другой стороны, менее явен, поскольку блокировка и разблокировка происходят неявно при входе и выходе из синхронизированного метода или блока кода.

Производительность:
* В некоторых случаях ReentrantLock может обеспечить лучшую производительность, чем synchronized, особенно если есть много потоков и блокировка происходит часто.
* Однако в большинстве простых случаев synchronized может быть достаточно эффективным и предпочтительным в использовании из-за своей простоты.

Исключения:
* ReentrantLock позволяет использовать обработку исключений в более гибком режиме, чем synchronized, потому что метод lock() может быть вызван в блоке try-catch-finally, что может быть полезно для разработки безопасного кода.

===

## Что такое "spin lock"?

===

"Spin lock" - это механизм синхронизации, при котором поток, желающий захватить блокировку (lock), повторяет цикл проверки до тех пор, пока блокировка не станет доступной. Вместо перевода потока в режим ожидания (например, с помощью операции блокировки), поток продолжает активно проверять доступность блокировки в цикле.

Основная идея "spin lock" состоит в том, чтобы минимизировать накладные расходы, связанные с переключением контекста (context switching), которые могут возникнуть при использовании более традиционных механизмов блокировки, таких как мьютексы (mutexes) или семафоры.

Однако, использование "spin lock" эффективно только в некоторых сценариях, например, в случае, когда ожидание блокировки ожидается на короткое время, и переключение контекста будет дороже, чем активное ожидание. В других сценариях, например, при долгом ожидании, активное ожидание может привести к избыточной загрузке процессора.

Использование "spin lock" обычно оправдано в высокопроизводительных приложениях с высокими требованиями к производительности и низкой задержкой. Однако, перед использованием "spin lock" необходимо произвести тщательный анализ и учитывать особенности конкретного сценария использования.

===

## Преимущества SheduledThreadPool перед java.util.Timer

===

ScheduledThreadPoolExecutor является более гибким и мощным инструментом для планирования задач по сравнению с java.util.Timer. Вот несколько преимуществ ScheduledThreadPoolExecutor перед Timer:

Потокобезопасность:
* ScheduledThreadPoolExecutor - это реализация ExecutorService, которая является потокобезопасной. Это означает, что можно отправлять задачи на выполнение в пул потоков из разных частей приложения без опасения за состояние гонки.
* java.util.Timer не является потокобезопасным. Вам придется самостоятельно обеспечить синхронизацию доступа к объекту Timer из разных потоков.

Гибкость конфигурации:
* ScheduledThreadPoolExecutor позволяет гибко настраивать параметры пула потоков, такие как размер пула, время ожидания перед выполнением задачи и т. д.
* java.util.Timer предоставляет только ограниченные возможности конфигурации, и вы не можете управлять внутренними параметрами потока, используемого для выполнения задач.

Обработка ошибок:
* ScheduledThreadPoolExecutor предоставляет улучшенные механизмы обработки ошибок. Вы можете определить обработчик ошибок для каждой задачи или для всего пула потоков.
* java.util.Timer обычно просто игнорирует исключения, возникающие внутри задачи, что может быть неудобно для отладки и обработки ошибок.

Гибкость планирования:
* ScheduledThreadPoolExecutor позволяет создавать несколько планировщиков задач с разными параметрами, что обеспечивает большую гибкость при планировании задач.
* java.util.Timer ограничен одним планировщиком задач.

===

## Различия между java.util.concurrent.Atomic*.compareAndSwap() и java.util.concurrent.Atomic*.weakCompareAndSwap()

===

compareAndSet():
* Этот метод является строгим (strong) методом сравнения и установки.
* Он выполняет операцию установки нового значения переменной, только если текущее значение равно ожидаемому (expected).
* Если текущее значение переменной не равно ожидаемому, метод не выполняет никаких изменений и возвращает false.
* Этот метод обеспечивает строгую семантику сравнения и установки и гарантирует, что обновление переменной произойдет только в случае выполнения условия.

weakCompareAndSet():
* Этот метод является слабым (weak) методом сравнения и установки.
* Могут быть ложные ошибки при получении монопольного доступа на аппаратном уровне.
* Не обеспечивает гарантии упорядочения.

===

## Отличие Thread.start() и Thread.run()

===

start запускает новый поток и вызывает в нем run.

run исполняется в текущем потоке

===

## Что такое "рандеву"? При помощи каких классов в Java его можно организовать?

===

"Рандеву" (rendezvous) в контексте многопоточного программирования обозначает ситуацию, когда два или более потока должны встретиться в определенной точке выполнения программы перед тем, как продолжить свою работу. То есть, каждый поток ожидает другой поток в определенном месте кода, и оба потока не могут продолжить выполнение, пока не встретятся.

В Java рандеву можно организовать с использованием различных классов и механизмов. Некоторые из них:
1. Метод join() класса Thread:
    * Позволяет одному потоку ожидать завершения выполнения другого потока.
    * Поток, вызывающий join(), приостанавливается до тех пор, пока поток, для которого вызван join(), не завершит свою работу.
2. Класс CountDownLatch:
   * Позволяет одному или нескольким потокам ожидать завершения выполнения набора операций другими потоками.
     * Использует счетчик, который уменьшается по мере завершения каждой операции, и блокирует вызывающий поток, пока счетчик не достигнет нуля.
3. Классы CyclicBarrier и Phaser:
   * Позволяют группе потоков синхронизироваться на заданном этапе выполнения.
   * CyclicBarrier позволяет потокам ожидать друг друга на барьере, после чего все потоки могут продолжить выполнение.
   * Phaser предоставляет более гибкий механизм синхронизации, позволяющий потокам синхронизироваться в нескольких фазах.
4. Методы wait() и notify()/notifyAll() в классе Object:
   * Позволяют потокам ожидать уведомления о событиях от других потоков.
   * wait() приостанавливает текущий поток и освобождает монитор объекта, а notify()/notifyAll() используются для уведомления потоков о том, что событие произошло и они могут продолжить выполнение.

===
